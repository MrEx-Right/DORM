package exploitdb // <--- Folder name must be 'exploitdb'

import (
	"encoding/csv"
	"fmt"
	"net/http"
	"strings"
	"sync"
	"time"
)

// Exploit Data Structure
type Exploit struct {
	ID          string
	Description string
}

// Global Variables (Live only within this package)
var (
	database []Exploit
	isLoaded bool
	mutex    sync.Mutex
)

// ==========================================
// 1. DOWNLOAD DATABASE AND LOAD INTO RAM
// ==========================================
func Load() error {
	mutex.Lock()
	defer mutex.Unlock()

	if isLoaded {
		return nil
	}

	fmt.Println("[*] Downloading Exploit-DB database (files_exploits.csv)...")

	// Official GitLab Repo for Exploit-DB
	url := "https://gitlab.com/exploit-database/exploitdb/-/raw/main/files_exploits.csv"
	client := &http.Client{Timeout: 30 * time.Second}

	resp, err := client.Get(url)
	if err != nil {
		return fmt.Errorf("download error: %v", err)
	}
	defer resp.Body.Close()

	// CSV Reader
	reader := csv.NewReader(resp.Body)
	records, err := reader.ReadAll()
	if err != nil {
		return fmt.Errorf("CSV reading error: %v", err)
	}

	// Fill into RAM
	for i, record := range records {
		if i == 0 {
			continue
		} // Skip header
		if len(record) < 3 {
			continue
		}

		// ID and Description are enough for us
		database = append(database, Exploit{
			ID:          record[0],
			Description: strings.ToLower(record[2]), // Convert to lowercase for easy searching
		})
	}

	isLoaded = true
	fmt.Printf("[+] Exploit-DB Ready! %d records loaded into RAM.\n", len(database))
	return nil
}

// ==========================================
// 2. SMART SEARCH ENGINE
// ==========================================
func Search(query string) []string {
	if !isLoaded {
		Load() // Lazy load: Download only if needed
	}

	// Smart Search Logic:
	// Split query into terms. E.g., "Apache 2.4" -> ["apache", "2.4"]
	// Verify if the description contains ALL terms.
	query = strings.ToLower(query)
	searchTerms := strings.Fields(query)

	var results []string
	count := 0

	// Scan thousands of records in RAM
	for _, item := range database {
		match := true

		// Check if ALL keywords exist in the description
		for _, term := range searchTerms {
			if !strings.Contains(item.Description, term) {
				match = false
				break
			}
		}

		if match {
			link := fmt.Sprintf("https://www.exploit-db.com/exploits/%s", item.ID)
			// Format the output
			results = append(results, fmt.Sprintf("FOUND: %s\n   Link: %s", item.Description, link))

			count++
			if count >= 5 {
				break
			} // Limit to top 5 results to avoid flooding
		}
	}

	return results
}
